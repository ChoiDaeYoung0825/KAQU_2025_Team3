import rclpy
import numpy as np
from InverseKinematics import robot_IK
from PIDController import PID_controller
from RobotUtilities.Transformations import rotxyz

class RestController(object):
    def __init__(self, default_stance):
        self.def_stance = default_stance

        # TODO : 게인값 조율
        self.pid_controller = PID_controller(0., 0., 0.)
        self.use_imu = False  #관성 보정 사용X (처음이니까
        self.use_button = True	#특정 버튼으로 IMU on/off 가능?
        self.pid_controller.reset()	#PID 초기화 
        
    def updateStateCommand(self, msg, state, command):
        # local body position / orientation
        state.body_local_position[0] = msg.axes[7]*0.04  #msg.oxes = 조이스틱, 패드의 입력값
        state.body_local_position[1] = msg.axes[6]*0.03  #-> 로봇 몸체의 x,y,z 이동량으로
        state.body_local_position[2] = msg.axes[1]*0.03

        state.body_local_orientation[0] = msg.axes[0]*0.4 #-> 롤,피치,야오
        state.body_local_orientation[1] = msg.axes[4]*0.5
        state.body_local_orientation[2] = msg.axes[3]*0.4
        
        if self.use_button:
            if msg.buttons[7]:
                self.use_imu = not self.use_imu  #IMU 토글
                self.use_button = False #한 번 때야 이동가능
                print(f"RESTController - Use rp compensation : {self.use_imu}")
        if not self.use_button:	#한 번 때야 이동가능
            if not (msg.buttons[7]):
                self.use_button = True
    @property
    def default_stance(self):
        return self.def_stance
    
    def step(self, state, command):
        temp = self.default_stance
        temp[2] = [command.robot_height]*4 #발끝  z좌표를 모두 command.robot.height로 설정

        # rp compensation
        # 나중에 이 부분 수정하면 됨 / 발끝 계산하는 부분?
        if self.use_imu:  #IMU 보정
            compensation = self.pid_controller.run(state.imu_roll, state.imu_pitch) #PID 보정계산
            roll_compensation = -compensation[0]	#PID 보정 넣기
            pitch_compensation = -compensation[1]

            rot = rotxyz(roll_compensation, pitch_compensation, 0)
            temp = np.matmul(rot, temp)	#좌표들이 회전 행렬에 의해 일괄적으로 회전
        return temp	#지금 PID게인은 0이지만 수정하면 적용가능
        
    def run(self, state, command):	#최종 발끝 계산 )매 주기마다 step호출
        state.foot_locations = self.step(state, command)
        return state.foot_locations
